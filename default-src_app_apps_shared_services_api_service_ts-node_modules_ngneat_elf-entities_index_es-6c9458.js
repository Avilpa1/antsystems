"use strict";
(self["webpackChunkantsystems_frontend"] = self["webpackChunkantsystems_frontend"] || []).push([["default-src_app_apps_shared_services_api_service_ts-node_modules_ngneat_elf-entities_index_es-6c9458"],{

/***/ 7024:
/*!*****************************************************!*\
  !*** ./src/app/apps/shared/services/api.service.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApiService: () => (/* binding */ ApiService)
/* harmony export */ });
/* harmony import */ var _environments_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../environments/environment */ 6716);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 4280);
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common/http */ 1332);



class ApiService {
  constructor(http) {
    this.http = http;
    this.baseUrl = '';
    this.baseUrl = _environments_environment__WEBPACK_IMPORTED_MODULE_0__.environment.apiUrl;
  }
  get(path) {
    // return this.http.get(`${this.baseUrl}/${path}`)
    return this.http.get(`${path}`);
  }
  static #_ = this.ɵfac = function ApiService_Factory(t) {
    return new (t || ApiService)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common_http__WEBPACK_IMPORTED_MODULE_2__.HttpClient));
  };
  static #_2 = this.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: ApiService,
    factory: ApiService.ɵfac,
    providedIn: 'root'
  });
}

/***/ }),

/***/ 5768:
/*!********************************************************!*\
  !*** ./node_modules/@ngneat/elf-entities/index.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EntitiesRef: () => (/* binding */ EntitiesRef),
/* harmony export */   UIEntitiesRef: () => (/* binding */ UIEntitiesRef),
/* harmony export */   addActiveIds: () => (/* binding */ addActiveIds),
/* harmony export */   addEntities: () => (/* binding */ addEntities),
/* harmony export */   addEntitiesFifo: () => (/* binding */ addEntitiesFifo),
/* harmony export */   deleteAllEntities: () => (/* binding */ deleteAllEntities),
/* harmony export */   deleteEntities: () => (/* binding */ deleteEntities),
/* harmony export */   deleteEntitiesByPredicate: () => (/* binding */ deleteEntitiesByPredicate),
/* harmony export */   entitiesPropsFactory: () => (/* binding */ entitiesPropsFactory),
/* harmony export */   getActiveEntities: () => (/* binding */ getActiveEntities),
/* harmony export */   getActiveEntity: () => (/* binding */ getActiveEntity),
/* harmony export */   getActiveId: () => (/* binding */ getActiveId),
/* harmony export */   getActiveIds: () => (/* binding */ getActiveIds),
/* harmony export */   getAllEntities: () => (/* binding */ getAllEntities),
/* harmony export */   getAllEntitiesApply: () => (/* binding */ getAllEntitiesApply),
/* harmony export */   getEntitiesCount: () => (/* binding */ getEntitiesCount),
/* harmony export */   getEntitiesCountByPredicate: () => (/* binding */ getEntitiesCountByPredicate),
/* harmony export */   getEntitiesIds: () => (/* binding */ getEntitiesIds),
/* harmony export */   getEntity: () => (/* binding */ getEntity$1),
/* harmony export */   getEntityByPredicate: () => (/* binding */ getEntityByPredicate),
/* harmony export */   hasEntity: () => (/* binding */ hasEntity),
/* harmony export */   moveEntity: () => (/* binding */ moveEntity),
/* harmony export */   removeActiveIds: () => (/* binding */ removeActiveIds),
/* harmony export */   resetActiveId: () => (/* binding */ resetActiveId),
/* harmony export */   resetActiveIds: () => (/* binding */ resetActiveIds),
/* harmony export */   selectActiveEntities: () => (/* binding */ selectActiveEntities),
/* harmony export */   selectActiveEntity: () => (/* binding */ selectActiveEntity),
/* harmony export */   selectActiveId: () => (/* binding */ selectActiveId),
/* harmony export */   selectActiveIds: () => (/* binding */ selectActiveIds),
/* harmony export */   selectAllEntities: () => (/* binding */ selectAllEntities),
/* harmony export */   selectAllEntitiesApply: () => (/* binding */ selectAllEntitiesApply),
/* harmony export */   selectEntities: () => (/* binding */ selectEntities),
/* harmony export */   selectEntitiesCount: () => (/* binding */ selectEntitiesCount),
/* harmony export */   selectEntitiesCountByPredicate: () => (/* binding */ selectEntitiesCountByPredicate),
/* harmony export */   selectEntity: () => (/* binding */ selectEntity),
/* harmony export */   selectEntityByPredicate: () => (/* binding */ selectEntityByPredicate),
/* harmony export */   selectFirst: () => (/* binding */ selectFirst),
/* harmony export */   selectLast: () => (/* binding */ selectLast),
/* harmony export */   selectMany: () => (/* binding */ selectMany),
/* harmony export */   selectManyByPredicate: () => (/* binding */ selectManyByPredicate),
/* harmony export */   setActiveId: () => (/* binding */ setActiveId),
/* harmony export */   setActiveIds: () => (/* binding */ setActiveIds),
/* harmony export */   setEntities: () => (/* binding */ setEntities),
/* harmony export */   setEntitiesMap: () => (/* binding */ setEntitiesMap),
/* harmony export */   toggleActiveIds: () => (/* binding */ toggleActiveIds),
/* harmony export */   unionEntities: () => (/* binding */ unionEntities),
/* harmony export */   unionEntitiesAsMap: () => (/* binding */ unionEntitiesAsMap),
/* harmony export */   updateAllEntities: () => (/* binding */ updateAllEntities),
/* harmony export */   updateEntities: () => (/* binding */ updateEntities),
/* harmony export */   updateEntitiesByPredicate: () => (/* binding */ updateEntitiesByPredicate),
/* harmony export */   updateEntitiesIds: () => (/* binding */ updateEntitiesIds),
/* harmony export */   upsertEntities: () => (/* binding */ upsertEntities),
/* harmony export */   upsertEntitiesById: () => (/* binding */ upsertEntitiesById),
/* harmony export */   withActiveId: () => (/* binding */ withActiveId),
/* harmony export */   withActiveIds: () => (/* binding */ withActiveIds),
/* harmony export */   withEntities: () => (/* binding */ withEntities),
/* harmony export */   withUIEntities: () => (/* binding */ withUIEntities)
/* harmony export */ });
/* harmony import */ var _ngneat_elf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ngneat/elf */ 565);

function buildEntities(entities, idKey) {
  const asObject = {};
  const ids = [];
  for (const entity of entities) {
    const id = entity[idKey];
    ids.push(id);
    asObject[id] = entity;
  }
  return {
    ids,
    asObject
  };
}
function findIdsByPredicate(state, ref, predicate) {
  const {
    idsKey,
    entitiesKey
  } = ref;
  const entities = state[entitiesKey];
  return state[idsKey].filter(id => predicate(entities[id]));
}
function findEntityByPredicate(state, ref, predicate) {
  const {
    idsKey,
    entitiesKey
  } = ref;
  const entities = state[entitiesKey];
  const id = state[idsKey].find(id => {
    return predicate(entities[id]);
  });
  return entities[id];
}
function checkPluck(entity, pluck) {
  if (entity && pluck) {
    return (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.isFunction)(pluck) ? pluck(entity) : entity[pluck];
  } else {
    return entity;
  }
}
function getIdKey(context, ref) {
  return context.config[ref.idKeyRef];
}

// This will return { entitiesKey: "entities", idsKey: "ids" }

// This will return { entities: any, ids: any }

class EntitiesRef {
  constructor(config) {
    this.entitiesKey = void 0;
    this.idsKey = void 0;
    this.idKeyRef = 'idKey';
    this.entitiesKey = config.entitiesKey;
    this.idsKey = config.idsKey;
    this.idKeyRef = config.idKeyRef;
  }
}
function entitiesPropsFactory(feature) {
  const idKeyRef = feature ? `idKey${(0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.capitalize)(feature)}` : 'idKey';
  const ref = new EntitiesRef({
    entitiesKey: feature ? `${feature}Entities` : 'entities',
    idsKey: feature ? `${feature}Ids` : 'ids',
    idKeyRef: idKeyRef
  });
  function propsFactory(config) {
    let entities = {};
    let ids = [];
    const idKey = config?.idKey || 'id';
    if (config?.initialValue) {
      ({
        ids,
        asObject: entities
      } = buildEntities(config.initialValue, idKey));
    }
    return {
      props: {
        [ref.entitiesKey]: entities,
        [ref.idsKey]: ids
      },
      config: {
        [idKeyRef]: idKey
      }
    };
  }
  return {
    [`${feature}EntitiesRef`]: ref,
    [`with${(0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.capitalize)(feature)}Entities`]: propsFactory
  };
}
const {
  withEntities,
  EntitiesRef: defaultEntitiesRef
} = entitiesPropsFactory('');
const {
  UIEntitiesRef,
  withUIEntities
} = entitiesPropsFactory('UI');

/**
 *
 * Remove entities
 *
 * @example
 *
 * store.update(deleteEntities(1))
 *
 * store.update(deleteEntities([1, 2, 3])
 *
 */
function deleteEntities(ids, options = {}) {
  return function (state) {
    const {
      ref: {
        idsKey,
        entitiesKey
      } = defaultEntitiesRef
    } = options;
    const idsToRemove = (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.coerceArray)(ids);
    const newEntities = {
      ...state[entitiesKey]
    };
    const newIds = state[idsKey].filter(id => !idsToRemove.includes(id));
    for (const id of idsToRemove) {
      Reflect.deleteProperty(newEntities, id);
    }
    return {
      ...state,
      [entitiesKey]: newEntities,
      [idsKey]: newIds
    };
  };
}

/**
 *
 * Remove entities by predicate
 *
 * @example
 *
 * store.update(deleteEntitiesByPredicate(entity => entity.count === 0))
 *
 */
function deleteEntitiesByPredicate(predicate, options = {}) {
  return function reducer(state, context) {
    const ids = findIdsByPredicate(state, options.ref || defaultEntitiesRef, predicate);
    if (ids.length) {
      return deleteEntities(ids, options)(state, context);
    }
    return state;
  };
}

/**
 *
 * Remove all entities
 *
 * @example
 *
 * store.update(deleteAllEntities())
 *
 */
function deleteAllEntities(options = {}) {
  return function reducer(state) {
    const {
      ref: {
        idsKey,
        entitiesKey
      } = defaultEntitiesRef
    } = options;
    return {
      ...state,
      [entitiesKey]: {},
      [idsKey]: []
    };
  };
}

/**
 *
 * Add entities
 *
 * @example
 *
 * store.update(addEntities(entity))
 *
 * store.update(addEntities([entity, entity]))
 *
 * store.update(addEntities([entity, entity]), { prepend: true })
 *
 */
function addEntities(entities, options = {}) {
  return function (state, context) {
    const {
      prepend = false,
      ref = defaultEntitiesRef
    } = options;
    const {
      entitiesKey,
      idsKey
    } = ref;
    const idKey = getIdKey(context, ref);
    const asArray = (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.coerceArray)(entities);
    if (!asArray.length) return state;
    if ((0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.isDev)()) {
      throwIfEntityExists(asArray, idKey, state, entitiesKey);
      throwIfDuplicateIdKey(asArray, idKey);
    }
    const {
      ids,
      asObject
    } = buildEntities(asArray, idKey);
    return {
      ...state,
      [entitiesKey]: {
        ...state[entitiesKey],
        ...asObject
      },
      [idsKey]: prepend ? [...ids, ...state[idsKey]] : [...state[idsKey], ...ids]
    };
  };
}

/**
 *
 * Add entities using fifo
 *
 * @example
 *
 *
 * store.update(addEntitiesFifo([entity, entity]), { limit: 3 })
 *
 */
function addEntitiesFifo(entities, options) {
  return function (state, context) {
    const {
      ref = defaultEntitiesRef,
      limit
    } = options;
    const {
      entitiesKey,
      idsKey
    } = ref;
    const currentIds = state[idsKey];
    let normalizedEntities = (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.coerceArray)(entities);
    let newState = state;
    if (normalizedEntities.length > limit) {
      // Remove new entities that pass the limit
      normalizedEntities = normalizedEntities.slice(normalizedEntities.length - limit);
    }
    const total = currentIds.length + normalizedEntities.length;

    // Remove exiting entities that passes the limit
    if (total > limit) {
      const idsRemove = currentIds.slice(0, total - limit);
      newState = deleteEntities(idsRemove)(state, context);
    }
    const {
      ids,
      asObject
    } = buildEntities(normalizedEntities, getIdKey(context, ref));
    return {
      ...state,
      [entitiesKey]: {
        ...newState[entitiesKey],
        ...asObject
      },
      [idsKey]: [...newState[idsKey], ...ids]
    };
  };
}
function throwIfEntityExists(entities, idKey, state, entitiesKey) {
  entities.forEach(entity => {
    const id = entity[idKey];
    if (state[entitiesKey][id]) {
      throw Error(`Entity already exists. ${idKey} ${id}`);
    }
  });
}
function throwIfDuplicateIdKey(entities, idKey) {
  const check = new Set();
  entities.forEach(entity => {
    const id = entity[idKey];
    if (check.has(id)) {
      throw Error(`Duplicate entity id provided. ${idKey} ${id}`);
    }
    check.add(id);
  });
}

/**
 *
 * Set entities
 *
 * @example
 *
 * store.update(setEntities([entity, entity]))
 *
 */
function setEntities(entities, options = {}) {
  return function (state, context) {
    const {
      ref = defaultEntitiesRef
    } = options;
    const {
      entitiesKey,
      idsKey
    } = ref;
    const {
      ids,
      asObject
    } = buildEntities(entities, getIdKey(context, ref));
    return {
      ...state,
      [entitiesKey]: asObject,
      [idsKey]: ids
    };
  };
}
function setEntitiesMap(entities, options = {}) {
  return setEntities(Object.values(entities), options);
}

/**
 *
 * Get the entities collection
 *
 * @example
 *
 * store.query(getAllEntities())
 *
 */
function getAllEntities(options = {}) {
  const {
    ref: {
      entitiesKey,
      idsKey
    } = defaultEntitiesRef
  } = options;
  return function (state) {
    return state[idsKey].map(id => state[entitiesKey][id]);
  };
}

/**
 *
 * Get the entities and apply filter/map
 *
 * @example
 *
 * store.query(getAllEntitiesApply())
 *
 */
function getAllEntitiesApply(options) {
  const {
    ref: {
      entitiesKey,
      idsKey
    } = defaultEntitiesRef,
    filterEntity = () => true,
    mapEntity = e => e
  } = options;
  return function (state) {
    const result = [];
    for (const id of state[idsKey]) {
      const entity = state[entitiesKey][id];
      if (filterEntity(entity)) {
        result.push(mapEntity(entity));
      }
    }
    return result;
  };
}

/**
 *
 * Get an entity
 *
 * @example
 *
 * store.query(getEntity(1))
 *
 */
function getEntity$1(id, options = {}) {
  return function (state) {
    const {
      ref: {
        entitiesKey
      } = defaultEntitiesRef
    } = options;
    return state[entitiesKey][id];
  };
}

/**
 *
 * Get first entity by predicate
 *
 * @example
 *
 * store.query(getEntityByPredicate(({ title }) => title === 'Elf'))
 *
 */
function getEntityByPredicate(predicate, options = {}) {
  return function (state) {
    const {
      ref: {
        entitiesKey,
        idsKey
      } = defaultEntitiesRef
    } = options;
    const entities = state[entitiesKey];
    const id = state[idsKey].find(id => {
      return predicate(entities[id]);
    });
    return entities[id];
  };
}

/**
 *
 * Check whether the entity exist
 *
 * @example
 *
 * store.query(hasEntity(1))
 *
 */
function hasEntity(id, options = {}) {
  return function (state) {
    const {
      ref: {
        entitiesKey
      } = defaultEntitiesRef
    } = options;
    return Reflect.has(state[entitiesKey], id);
  };
}

/**
 *
 * Get the entities ids
 *
 * @example
 *
 * store.query(getEntitiesIds())
 *
 */
function getEntitiesIds(options = {}) {
  return function (state) {
    const {
      ref: {
        idsKey
      } = defaultEntitiesRef
    } = options;
    return state[idsKey];
  };
}
function toModel(updater, entity) {
  if ((0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.isFunction)(updater)) {
    return updater(entity);
  }
  return {
    ...entity,
    ...updater
  };
}

/**
 *
 * Update entities
 *
 * @example
 *
 * store.update(updateEntities(id, { name }))
 * store.update(updateEntities(id, entity => ({ ...entity, name })))
 * store.update(updateEntities([id, id, id], { open: true }))
 *
 */
function updateEntities(ids, updater, options = {}) {
  return function (state) {
    const {
      ref: {
        entitiesKey
      } = defaultEntitiesRef
    } = options;
    const updatedEntities = {};
    for (const id of (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.coerceArray)(ids)) {
      if (hasEntity(id, options)(state)) {
        updatedEntities[id] = toModel(updater, getEntity$1(id, options)(state));
      }
    }
    return {
      ...state,
      [entitiesKey]: {
        ...state[entitiesKey],
        ...updatedEntities
      }
    };
  };
}

/**
 *
 * Update entities by predicate
 *
 * @example
 *
 * store.update(updateEntitiesByPredicate(entity => entity.count === 0))
 *
 */
function updateEntitiesByPredicate(predicate, updater, options = {}) {
  return function (state, context) {
    const ids = findIdsByPredicate(state, options.ref || defaultEntitiesRef, predicate);
    if (ids.length) {
      return updateEntities(ids, updater, options)(state, context);
    }
    return state;
  };
}

/**
 *
 * Update all entities
 *
 * @example
 *
 * store.update(updateAllEntities({ name }))
 * store.update(updateAllEntities(entity => ({ ...entity, name })))
 *
 */
function updateAllEntities(updater, options = {}) {
  return function (state, context) {
    const {
      ref: {
        idsKey
      } = defaultEntitiesRef
    } = options;
    return updateEntities(state[idsKey], updater, options)(state, context);
  };
}
/**
 *
 * Update entities that exists, add those who don't
 *
 * @example
 *
 */
function upsertEntitiesById(ids, {
  updater,
  creator,
  ...options
}) {
  return function (state, context) {
    const updatedEntitiesIds = [];
    const newEntities = [];
    const asArray = (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.coerceArray)(ids);
    if (!asArray.length) return state;
    for (const id of asArray) {
      if (hasEntity(id, options)(state)) {
        updatedEntitiesIds.push(id);
      } else {
        let newEntity = creator(id);
        if (options.mergeUpdaterWithCreator) {
          newEntity = toModel(updater, newEntity);
        }
        newEntities.push(newEntity);
      }
    }
    const newState = updateEntities(updatedEntitiesIds, updater, options)(state, context);
    return addEntities(newEntities, options)(newState, context);
  };
}

/**
 *
 * Merge entities that exists, add those who don't
 * Make sure all entities have an id
 *
 * @example
 *
 * // single entity
 * store.update(upsertEntities({ id: 1, completed: true }))
 *
 * // or multiple entities
 * store.update(upsertEntities([{ id: 1, completed: true }, { id: 2, completed: true }]))
 *
 * // or using a custom ref
 * store.update(upsertEntities([{ id: 1, open: true }], { ref: UIEntitiesRef }))
 *
 */
function upsertEntities(entities, options = {}) {
  return function (state, context) {
    const {
      prepend = false,
      ref = defaultEntitiesRef
    } = options;
    const {
      entitiesKey,
      idsKey
    } = ref;
    const idKey = getIdKey(context, ref);
    const asObject = {};
    const ids = [];
    const entitiesArray = (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.coerceArray)(entities);
    if (!entitiesArray.length) {
      return state;
    }
    for (const entity of entitiesArray) {
      const id = entity[idKey];
      // if entity exists, merge update, else add
      if (hasEntity(id, options)(state)) {
        asObject[id] = {
          ...state[entitiesKey][id],
          ...entity
        };
      } else {
        ids.push(id);
        asObject[id] = entity;
      }
    }
    const updatedIds = !ids.length ? {} : {
      [idsKey]: prepend ? [...ids, ...state[idsKey]] : [...state[idsKey], ...ids]
    };
    return {
      ...state,
      ...updatedIds,
      [entitiesKey]: {
        ...state[entitiesKey],
        ...asObject
      }
    };
  };
}

/**
 * Update entities ids
 *
 * @example
 *
 * // Update a single entity id
 * store.update(updateEntitiesIds(1, 2));
 *
 * // Update multiple entities ids
 * store.update(updateEntitiesIds([1, 2], [10, 20]));
 *
 * // Update entity id using a custom ref
 * store.update(updateEntitiesIds(1, 2, { ref: UIEntitiesRef }));
 *
 */
function updateEntitiesIds(oldId, newId, options = {}) {
  return function (state, context) {
    const oldIds = (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.coerceArray)(oldId);
    const newIds = (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.coerceArray)(newId);
    if (oldIds.length !== newIds.length) {
      throw new Error('The number of old and new ids must be equal');
    }
    const {
      ref = defaultEntitiesRef
    } = options;
    const idProp = getIdKey(context, ref);
    const updatedEntities = {
      ...state[ref.entitiesKey]
    };
    for (let i = 0; i < oldIds.length; i++) {
      const oldVal = oldIds[i];
      const newVal = newIds[i];
      if (state[ref.entitiesKey][newVal]) {
        throw new Error(`Updating id "${oldVal}". The new id "${newVal}" already exists`);
      }
      const oldEntity = state[ref.entitiesKey][oldVal];
      const updated = {
        ...oldEntity,
        [idProp]: newVal
      };
      updatedEntities[newVal] = updated;
      Reflect.deleteProperty(updatedEntities, oldVal);
    }
    const updatedStateIds = state[ref.idsKey].slice();
    let processedIds = 0;
    for (let i = 0; i < updatedStateIds.length; i++) {
      const currentId = updatedStateIds[i];
      for (let j = 0; j < oldIds.length; j++) {
        const oldVal = oldIds[j];
        const newVal = newIds[j];
        if (currentId === oldVal) {
          updatedStateIds[i] = newVal;
          processedIds++;
          break;
        }
      }
      if (processedIds === oldIds.length) {
        break;
      }
    }
    return {
      ...state,
      [ref.entitiesKey]: updatedEntities,
      [ref.idsKey]: updatedStateIds
    };
  };
}

/**
 *
 * Move entity
 *
 * @example
 *
 * store.update(moveEntity({ fromIndex: 2, toIndex: 3}))
 *
 */
function moveEntity(options) {
  return function (state) {
    const {
      fromIndex,
      toIndex,
      ref: {
        idsKey,
        entitiesKey
      } = defaultEntitiesRef
    } = options;
    const ids = state[idsKey].slice();
    ids.splice(toIndex < 0 ? ids.length + toIndex : toIndex, 0, ids.splice(fromIndex, 1)[0]);
    return {
      ...state,
      [entitiesKey]: {
        ...state[entitiesKey]
      },
      [idsKey]: ids
    };
  };
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
    i,
    q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
    i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function isFunction(value) {
  return typeof value === 'function';
}
function createErrorClass(createImpl) {
  var _super = function (instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function (_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
      return i + 1 + ") " + err.toString();
    }).join('\n  ') : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription = function () {
  function Subscription(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription.prototype.unsubscribe = function () {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription.prototype.add = function (teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription.prototype._hasParent = function (parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription.prototype._addParent = function (parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription.prototype._removeParent = function (parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription.prototype.remove = function (teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription) {
      teardown._removeParent(this);
    }
  };
  Subscription.EMPTY = function () {
    var empty = new Subscription();
    empty.closed = true;
    return empty;
  }();
  return Subscription;
}();
Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: undefined,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function (handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function (handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: undefined
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function () {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
function noop() {}
var COMPLETE_NOTIFICATION = function () {
  return createNotification('C', undefined, undefined);
}();
function errorNotification(error) {
  return createNotification('E', undefined, error);
}
function nextNotification(value) {
  return createNotification('N', value, undefined);
}
function createNotification(kind, value, error) {
  return {
    kind: kind,
    value: value,
    error: error
  };
}
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = {
        errorThrown: false,
        error: null
      };
    }
    cb();
    if (isRoot) {
      var _a = context,
        errorThrown = _a.errorThrown,
        error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
var Subscriber = function (_super) {
  __extends(Subscriber, _super);
  function Subscriber(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber.create = function (next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber.prototype.next = function (value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber.prototype.error = function (err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber.prototype.complete = function () {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber.prototype.unsubscribe = function () {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber.prototype._next = function (value) {
    this.destination.next(value);
  };
  Subscriber.prototype._error = function (err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber.prototype._complete = function () {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function () {
  function ConsumerObserver(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver.prototype.next = function (value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver.prototype.error = function (err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver.prototype.complete = function () {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver;
}();
var SafeSubscriber = function (_super) {
  __extends(SafeSubscriber, _super);
  function SafeSubscriber(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,
        error: error !== null && error !== void 0 ? error : undefined,
        complete: complete !== null && complete !== void 0 ? complete : undefined
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function () {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function () {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
}();
function identity(x) {
  return x;
}
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function (prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function () {
  function Observable(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable.prototype.lift = function (operator) {
    var observable = new Observable();
    observable.source = this;
    observable.operator = operator;
    return observable;
  };
  Observable.prototype.subscribe = function (observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function () {
      var _a = _this,
        operator = _a.operator,
        source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable.prototype._trySubscribe = function (sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable.prototype.forEach = function (next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function (value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable.prototype._subscribe = function (subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable.prototype[observable] = function () {
    return this;
  };
  Observable.prototype.pipe = function () {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable.prototype.toPromise = function (promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var value;
      _this.subscribe(function (x) {
        return value = x;
      }, function (err) {
        return reject(err);
      }, function () {
        return resolve(value);
      });
    });
  };
  Observable.create = function (subscribe) {
    return new Observable(subscribe);
  };
  return Observable;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function (source) {
    if (hasLift(source)) {
      return source.lift(function (liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError('Unable to lift unknown Observable type');
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function (_super) {
  __extends(OperatorSubscriber, _super);
  function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function (value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function (err) {
      try {
        onError(err);
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function () {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber.prototype.unsubscribe = function () {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber;
}(Subscriber);
var isArrayLike = function (x) {
  return x && typeof x.length === 'number' && typeof x !== 'function';
};
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== 'function' || !Symbol.iterator) {
    return '@@iterator';
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function (_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1,, 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function (subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError('Provided object does not correctly implement Symbol.observable');
  });
}
function fromArrayLike(array) {
  return new Observable(function (subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function (subscriber) {
    promise.then(function (value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function (err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function (subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function (subscriber) {
    process(asyncIterable, subscriber).catch(function (err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function () {
    var value, e_2_1;
    return __generator(this, function (_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = {
            error: e_2_1
          };
          return [3, 11];
        case 6:
          _b.trys.push([6,, 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function map(project, thisArg) {
  return operate(function (source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function (source, subscriber) {
    var previousKey;
    var first = true;
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      var currentKey = keySelector(value);
      if (first || !comparator(previousKey, currentKey)) {
        first = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}
function switchMap(project, resultSelector) {
  return operate(function (source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function () {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function (innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function () {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function () {
      isComplete = true;
      checkComplete();
    }));
  });
}
function untilEntitiesChanges(key) {
  return distinctUntilChanged((prev, current) => {
    return prev[key] === current[key];
  });
}

/**
 *
 * Observe entities
 *
 * @example
 *
 * store.pipe(selectAllEntities())
 *
 * store.pipe(selectAllEntities({ ref: UIEntitiesRef }))
 *
 */
function selectAllEntities(options = {}) {
  const {
    ref: {
      entitiesKey,
      idsKey
    } = defaultEntitiesRef
  } = options;
  return pipe(untilEntitiesChanges(entitiesKey), map(state => state[idsKey].map(id => state[entitiesKey][id])));
}

/**
 *
 * Observe entities object
 *
 * @example
 *
 * store.pipe(selectEntities())
 *
 * store.pipe(selectEntities({ ref: UIEntitiesRef }))
 *
 */
function selectEntities(options = {}) {
  const {
    ref: {
      entitiesKey
    } = defaultEntitiesRef
  } = options;
  return (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => state[entitiesKey]);
}

/**
 *
 * Observe entities and apply filter/map
 *
 * @example
 *
 * store.pipe(selectAllEntitiesApply({
 *   map: (entity) => new Todo(entity),
 *   filter: entity => entity.completed
 * }))
 *
 *
 */
function selectAllEntitiesApply(options) {
  const {
    ref: {
      entitiesKey,
      idsKey
    } = defaultEntitiesRef,
    filterEntity = () => true,
    mapEntity = e => e
  } = options;
  return pipe(untilEntitiesChanges(entitiesKey), map(state => {
    const result = [];
    for (const id of state[idsKey]) {
      const entity = state[entitiesKey][id];
      if (filterEntity(entity)) {
        result.push(mapEntity(entity));
      }
    }
    return result;
  }));
}

/**
 * Observe an entity
 *
 * @example
 *
 * store.pipe(selectEntity(id, { pluck: 'title' })
 *
 * store.pipe(selectEntity(id, { ref: UIEntitiesRef })
 *
 */

/**
 * Observe an entity
 *
 * @example
 *
 * store.pipe(selectEntity(id, { pluck: e => e.title })
 *
 * store.pipe(selectEntity(id, { ref: UIEntitiesRef })
 *
 */

/**
 *
 * Observe an entity
 *
 * @example
 *
 * store.pipe(selectEntity(id))
 *
 * store.pipe(selectEntity(id, { ref: UIEntitiesRef })
 *
 */

function selectEntity(id, options = {}) {
  const {
    ref: {
      entitiesKey
    } = defaultEntitiesRef,
    pluck
  } = options;
  return pipe(untilEntitiesChanges(entitiesKey), (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => getEntity(state[entitiesKey], id, pluck)));
}
function getEntity(entities, id, pluck) {
  const entity = entities[id];
  if ((0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(entity)) {
    return undefined;
  }
  if (!pluck) {
    return entity;
  }
  return checkPluck(entity, pluck);
}

/**
 * Observe an entity
 *
 * @example
 *
 * store.pipe(selectEntityByPredicate(entity => entity.title, { pluck: entity => entity.title })
 *
 */

/**
 *
 * Observe an entity
 *
 * @example
 *
 * store.pipe(selectEntityByPredicate(entity => entity.title, { pluck: 'title' })
 *
 */

/**
 *
 * Observe an entity
 *
 * @example
 *
 * store.pipe(selectEntityByPredicate(entity => entity.title, { ref: UIEntitiesRef })
 *
 */

function selectEntityByPredicate(predicate, options) {
  const {
    ref = defaultEntitiesRef,
    pluck,
    idKey = 'id'
  } = options || {};
  const {
    entitiesKey
  } = ref;
  let id;
  return pipe((0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => {
    if ((0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(id)) {
      const entity = findEntityByPredicate(state, ref, predicate);
      id = entity && entity[idKey];
    }
    return state[entitiesKey][id];
  }), map(entity => entity ? checkPluck(entity, pluck) : undefined), distinctUntilChanged());
}

/**
 *
 * Observe the first entity
 *
 * @example
 *
 * store.pipe(selectFirst())
 *
 */
function selectFirst(options = {}) {
  const {
    ref: {
      entitiesKey,
      idsKey
    } = defaultEntitiesRef
  } = options;
  return (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => state[entitiesKey][state[idsKey][0]]);
}

/**
 *
 * Observe the last entity
 *
 * @example
 *
 * store.pipe(selectLast())
 *
 */
function selectLast(options = {}) {
  const {
    ref: {
      entitiesKey,
      idsKey
    } = defaultEntitiesRef
  } = options;
  return (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => state[entitiesKey][state[idsKey][state[idsKey].length - 1]]);
}

/**
 * Observe multiple entities
 *
 * @example
 *
 * store.pipe(selectMany([1,2,3], { pluck: 'title' })
 *
 */

/**
 * Observe multiple entities
 *
 * @example
 *
 * store.pipe(selectMany([1,2,3], { pluck: e => e.title })
 *
 */

/**
 * Observe multiple entities
 *
 * @example
 *
 * store.pipe(selectMany([1, 2, 3])
 *
 */

function selectMany(ids, options = {}) {
  const {
    ref: {
      entitiesKey
    } = defaultEntitiesRef,
    pluck
  } = options;
  return pipe((0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => state[entitiesKey]), map(entities => {
    if (!ids.length) return [];
    const filtered = [];
    for (const id of ids) {
      const entity = getEntity(entities, id, pluck);
      if (!(0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(entity)) filtered.push(entity);
    }
    return filtered;
  }), (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.distinctUntilArrayItemChanged)());
}
function selectManyByPredicate(predicate, options) {
  const {
    ref: {
      entitiesKey,
      idsKey
    } = defaultEntitiesRef,
    pluck
  } = options || {};
  return pipe(untilEntitiesChanges(entitiesKey), (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => {
    const filteredEntities = [];
    state[idsKey].forEach((id, index) => {
      const entity = state[entitiesKey][id];
      if (predicate(entity, index)) {
        filteredEntities.push(checkPluck(entity, pluck));
      }
    });
    return filteredEntities;
  }), (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.distinctUntilArrayItemChanged)());
}

/**
 *
 * Observe the entities collection size
 *
 * @example
 *
 * store.pipe(selectEntitiesCount())
 *
 */
function selectEntitiesCount(options = {}) {
  const {
    ref: {
      idsKey
    } = defaultEntitiesRef
  } = options;
  return (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => state[idsKey].length);
}

/**
 *
 * Observe the entities collection size  that pass the predicate
 *
 * @example
 *
 * store.pipe(selectEntitiesCountByPredicate(entity => entity.completed))
 *
 */
function selectEntitiesCountByPredicate(predicate, options = {}) {
  const ref = options.ref || defaultEntitiesRef;
  return pipe(untilEntitiesChanges(ref.entitiesKey), map(state => findIdsByPredicate(state, ref, predicate).length), distinctUntilChanged());
}

/**
 *
 * Return the entities collection size
 *
 * @example
 *
 * store.query(getEntitiesCount())
 *
 */
function getEntitiesCount(options = {}) {
  return function (state) {
    const {
      ref: {
        idsKey
      } = defaultEntitiesRef
    } = options;
    return state[idsKey].length;
  };
}

/**
 *
 * Return the entities collection size that pass the predicate
 *
 * @example
 *
 * store.query(getEntitiesCountByPredicate(entity => entity.completed))
 *
 */
function getEntitiesCountByPredicate(predicate, options = {}) {
  return function (state) {
    const ref = options.ref || defaultEntitiesRef;
    return findIdsByPredicate(state, ref, predicate).length;
  };
}
function unionEntities(idKey = 'id') {
  return map(state => {
    return state.entities.map(entity => {
      return {
        ...entity,
        ...state.UIEntities[entity[idKey]]
      };
    });
  });
}
function unionEntitiesAsMap(idKey = 'id') {
  return map(state => {
    return Object.fromEntries(state.entities.map(entity => {
      return [entity[idKey], {
        ...entity,
        ...state.UIEntities[entity[idKey]]
      }];
    }));
  });
}
const {
  selectActiveId,
  setActiveId,
  withActiveId,
  resetActiveId,
  getActiveId
} = (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.propsFactory)('activeId', {
  initialValue: undefined
});
function selectActiveEntity(options = {}) {
  const {
    ref = defaultEntitiesRef
  } = options;
  return function (source) {
    return source.pipe(selectActiveId()).pipe(switchMap(id => source.pipe(selectEntity(id, {
      ref
    }))));
  };
}
function getActiveEntity(options = {}) {
  const {
    ref: {
      entitiesKey
    } = defaultEntitiesRef
  } = options;
  return function (state) {
    return state[entitiesKey][getActiveId(state)];
  };
}
const {
  setActiveIds,
  resetActiveIds,
  withActiveIds,
  selectActiveIds,
  toggleActiveIds,
  removeActiveIds,
  addActiveIds,
  getActiveIds
} = (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.propsArrayFactory)('activeIds', {
  initialValue: []
});
function selectActiveEntities(options = {}) {
  const {
    ref = defaultEntitiesRef
  } = options;
  return function (source) {
    return source.pipe(selectActiveIds()).pipe(switchMap(ids => source.pipe(selectMany(ids, {
      ref
    }))));
  };
}
function getActiveEntities(options = {}) {
  const {
    ref: {
      entitiesKey
    } = defaultEntitiesRef
  } = options;
  return function (state) {
    const result = [];
    for (const id of getActiveIds(state)) {
      const entity = state[entitiesKey][id];
      if (entity) {
        result.push(entity);
      }
    }
    return result;
  };
}


/***/ }),

/***/ 2816:
/*!********************************************************!*\
  !*** ./node_modules/@ngneat/elf-requests/index.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearRequestsCache: () => (/* binding */ clearRequestsCache),
/* harmony export */   clearRequestsResult: () => (/* binding */ clearRequestsResult),
/* harmony export */   clearRequestsStatus: () => (/* binding */ clearRequestsStatus),
/* harmony export */   createRequestDataSource: () => (/* binding */ createRequestDataSource),
/* harmony export */   createRequestsCacheOperator: () => (/* binding */ createRequestsCacheOperator),
/* harmony export */   createRequestsStatusOperator: () => (/* binding */ createRequestsStatusOperator),
/* harmony export */   deleteRequestResult: () => (/* binding */ deleteRequestResult),
/* harmony export */   filterError: () => (/* binding */ filterError),
/* harmony export */   filterSuccess: () => (/* binding */ filterSuccess),
/* harmony export */   getRequestCache: () => (/* binding */ getRequestCache),
/* harmony export */   getRequestResult: () => (/* binding */ getRequestResult),
/* harmony export */   getRequestStatus: () => (/* binding */ getRequestStatus),
/* harmony export */   initializeAsPending: () => (/* binding */ initializeAsPending),
/* harmony export */   isRequestCached: () => (/* binding */ isRequestCached),
/* harmony export */   joinRequestResult: () => (/* binding */ joinRequestResult),
/* harmony export */   mapResultData: () => (/* binding */ mapResultData),
/* harmony export */   resetStaleTime: () => (/* binding */ resetStaleTime),
/* harmony export */   selectIsRequestCached: () => (/* binding */ selectIsRequestCached),
/* harmony export */   selectIsRequestPending: () => (/* binding */ selectIsRequestPending),
/* harmony export */   selectRequestCache: () => (/* binding */ selectRequestCache),
/* harmony export */   selectRequestStatus: () => (/* binding */ selectRequestStatus),
/* harmony export */   trackRequestResult: () => (/* binding */ trackRequestResult),
/* harmony export */   updateRequestCache: () => (/* binding */ updateRequestCache),
/* harmony export */   updateRequestStatus: () => (/* binding */ updateRequestStatus),
/* harmony export */   updateRequestsCache: () => (/* binding */ updateRequestsCache),
/* harmony export */   updateRequestsStatus: () => (/* binding */ updateRequestsStatus),
/* harmony export */   withRequestsCache: () => (/* binding */ withRequestsCache),
/* harmony export */   withRequestsStatus: () => (/* binding */ withRequestsStatus)
/* harmony export */ });
/* harmony import */ var _ngneat_elf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ngneat/elf */ 565);


/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
    i,
    q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
    i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function isFunction(value) {
  return typeof value === 'function';
}
function createErrorClass(createImpl) {
  var _super = function (instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function (_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
      return i + 1 + ") " + err.toString();
    }).join('\n  ') : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription = function () {
  function Subscription(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription.prototype.unsubscribe = function () {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription.prototype.add = function (teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription.prototype._hasParent = function (parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription.prototype._addParent = function (parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription.prototype._removeParent = function (parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription.prototype.remove = function (teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription) {
      teardown._removeParent(this);
    }
  };
  Subscription.EMPTY = function () {
    var empty = new Subscription();
    empty.closed = true;
    return empty;
  }();
  return Subscription;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: undefined,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function (handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function (handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: undefined
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function () {
    {
      throw err;
    }
  });
}
function noop() {}
function errorContext(cb) {
  {
    cb();
  }
}
var Subscriber = function (_super) {
  __extends(Subscriber, _super);
  function Subscriber(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber.create = function (next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber.prototype.next = function (value) {
    if (this.isStopped) ;else {
      this._next(value);
    }
  };
  Subscriber.prototype.error = function (err) {
    if (this.isStopped) ;else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber.prototype.complete = function () {
    if (this.isStopped) ;else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber.prototype.unsubscribe = function () {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber.prototype._next = function (value) {
    this.destination.next(value);
  };
  Subscriber.prototype._error = function (err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber.prototype._complete = function () {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function () {
  function ConsumerObserver(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver.prototype.next = function (value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver.prototype.error = function (err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver.prototype.complete = function () {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver;
}();
var SafeSubscriber = function (_super) {
  __extends(SafeSubscriber, _super);
  function SafeSubscriber(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,
        error: error !== null && error !== void 0 ? error : undefined,
        complete: complete !== null && complete !== void 0 ? complete : undefined
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function () {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
}();
function identity(x) {
  return x;
}
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function (prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function () {
  function Observable(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable.prototype.lift = function (operator) {
    var observable = new Observable();
    observable.source = this;
    observable.operator = operator;
    return observable;
  };
  Observable.prototype.subscribe = function (observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function () {
      var _a = _this,
        operator = _a.operator,
        source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable.prototype._trySubscribe = function (sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable.prototype.forEach = function (next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function (value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable.prototype._subscribe = function (subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable.prototype[observable] = function () {
    return this;
  };
  Observable.prototype.pipe = function () {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable.prototype.toPromise = function (promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var value;
      _this.subscribe(function (x) {
        return value = x;
      }, function (err) {
        return reject(err);
      }, function () {
        return resolve(value);
      });
    });
  };
  Observable.create = function (subscribe) {
    return new Observable(subscribe);
  };
  return Observable;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function (source) {
    if (hasLift(source)) {
      return source.lift(function (liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError('Unable to lift unknown Observable type');
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function (_super) {
  __extends(OperatorSubscriber, _super);
  function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function (value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function (err) {
      try {
        onError(err);
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function () {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber.prototype.unsubscribe = function () {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber;
}(Subscriber);
var ObjectUnsubscribedError = createErrorClass(function (_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = 'ObjectUnsubscribedError';
    this.message = 'object unsubscribed';
  };
});
var Subject = function (_super) {
  __extends(Subject, _super);
  function Subject() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject.prototype.lift = function (operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject.prototype._throwIfClosed = function () {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject.prototype.next = function (value) {
    var _this = this;
    errorContext(function () {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject.prototype.error = function (err) {
    var _this = this;
    errorContext(function () {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject.prototype.complete = function () {
    var _this = this;
    errorContext(function () {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject.prototype.unsubscribe = function () {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject.prototype, "observed", {
    get: function () {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject.prototype._trySubscribe = function (subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject.prototype._subscribe = function (subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject.prototype._innerSubscribe = function (subscriber) {
    var _this = this;
    var _a = this,
      hasError = _a.hasError,
      isStopped = _a.isStopped,
      observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function () {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject.prototype._checkFinalizedStatuses = function (subscriber) {
    var _a = this,
      hasError = _a.hasError,
      thrownError = _a.thrownError,
      isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject.prototype.asObservable = function () {
    var observable = new Observable();
    observable.source = this;
    return observable;
  };
  Subject.create = function (destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject;
}(Observable);
var AnonymousSubject = function (_super) {
  __extends(AnonymousSubject, _super);
  function AnonymousSubject(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject.prototype.next = function (value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject.prototype.error = function (err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject.prototype.complete = function () {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject.prototype._subscribe = function (subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject;
}(Subject);
var BehaviorSubject = function (_super) {
  __extends(BehaviorSubject, _super);
  function BehaviorSubject(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject.prototype, "value", {
    get: function () {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject.prototype._subscribe = function (subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject.prototype.getValue = function () {
    var _a = this,
      hasError = _a.hasError,
      thrownError = _a.thrownError,
      _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject.prototype.next = function (value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject;
}(Subject);
var EMPTY = new Observable(function (subscriber) {
  return subscriber.complete();
});
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : undefined;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : undefined;
}
var isArrayLike = function (x) {
  return x && typeof x.length === 'number' && typeof x !== 'function';
};
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== 'function' || !Symbol.iterator) {
    return '@@iterator';
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function (_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1,, 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function (subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError('Provided object does not correctly implement Symbol.observable');
  });
}
function fromArrayLike(array) {
  return new Observable(function (subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function (subscriber) {
    promise.then(function (value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function (err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function (subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function (subscriber) {
    process(asyncIterable, subscriber).catch(function (err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function () {
    var value, e_2_1;
    return __generator(this, function (_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = {
            error: e_2_1
          };
          return [3, 11];
        case 6:
          _b.trys.push([6,, 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function () {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function (source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      return executeSchedule(subscriber, scheduler, function () {
        return subscriber.next(value);
      }, delay);
    }, function () {
      return executeSchedule(subscriber, scheduler, function () {
        return subscriber.complete();
      }, delay);
    }, function (err) {
      return executeSchedule(subscriber, scheduler, function () {
        return subscriber.error(err);
      }, delay);
    }));
  });
}
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function (source, subscriber) {
    subscriber.add(scheduler.schedule(function () {
      return source.subscribe(subscriber);
    }, delay));
  });
}
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function scheduleArray(input, scheduler) {
  return new Observable(function (subscriber) {
    var i = 0;
    return scheduler.schedule(function () {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable(input, scheduler) {
  return new Observable(function (subscriber) {
    var iterator$1;
    executeSchedule(subscriber, scheduler, function () {
      iterator$1 = input[iterator]();
      executeSchedule(subscriber, scheduler, function () {
        var _a;
        var value;
        var done;
        try {
          _a = iterator$1.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function () {
      return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
    };
  });
}
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error('Iterable cannot be null');
  }
  return new Observable(function (subscriber) {
    executeSchedule(subscriber, scheduler, function () {
      var iterator = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function () {
        iterator.next().then(function (result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function () {
    return errorOrErrorFactory;
  };
  var init = function (subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function (subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}
function map(project, thisArg) {
  return operate(function (source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
var isArray$1 = Array.isArray;
function callOrApply(fn, args) {
  return isArray$1(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function (args) {
    return callOrApply(fn, args);
  });
}
var isArray = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf,
  objectProto = Object.prototype,
  getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray(first_1)) {
      return {
        args: first_1,
        keys: null
      };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function (key) {
          return first_1[key];
        }),
        keys: keys
      };
    }
  }
  return {
    args: args,
    keys: null
  };
}
function isPOJO(obj) {
  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;
}
function createObject(keys, values) {
  return keys.reduce(function (result, key, i) {
    return result[key] = values[i], result;
  }, {});
}
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args),
    observables = _a.args,
    keys = _a.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function (values) {
    return createObject(keys, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function (subscriber) {
    maybeSchedule(scheduler, function () {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function (i) {
        maybeSchedule(scheduler, function () {
          var source = from(observables[i], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function (value) {
            values[i] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function () {
            if (! --active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
function defer(observableFactory) {
  return new Observable(function (subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}
function filter(predicate, thisArg) {
  return operate(function (source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
function take(count) {
  return count <= 0 ? function () {
    return EMPTY;
  } : operate(function (source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function (source, subscriber) {
    var previousKey;
    var first = true;
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      var currentKey = keySelector(value);
      if (first || !comparator(previousKey, currentKey)) {
        first = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}
function distinctUntilKeyChanged(key, compare) {
  return distinctUntilChanged(function (x, y) {
    return compare ? compare(x[key], y[key]) : x[key] === y[key];
  });
}
function switchMap(project, resultSelector) {
  return operate(function (source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function () {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function (innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function () {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function () {
      isComplete = true;
      checkComplete();
    }));
  });
}
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? {
    next: observerOrNext,
    error: error,
    complete: complete
  } : observerOrNext;
  return tapObserver ? operate(function (source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      var _a;
      (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
      subscriber.next(value);
    }, function () {
      var _a;
      isUnsub = false;
      (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      subscriber.complete();
    }, function (err) {
      var _a;
      isUnsub = false;
      (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
      subscriber.error(err);
    }, function () {
      var _a, _b;
      if (isUnsub) {
        (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}
function withRequestsCache(initialValue) {
  return {
    props: {
      requestsCache: initialValue ?? {}
    },
    config: undefined
  };
}
function selectRequestCache(key) {
  return pipe(distinctUntilKeyChanged('requestsCache'), (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => getRequestCache(key)(state)));
}
function updateRequestsCache(requestsOrKeys, value) {
  let normalized = requestsOrKeys;
  if (value) {
    normalized = requestsOrKeys.reduce((acc, key) => {
      const data = {
        value: value.value ?? 'full'
      };
      if (value.ttl) {
        data.timestamp = Date.now() + value.ttl;
      }
      acc[key] = data;
      return acc;
    }, {});
  }
  return function (state) {
    return {
      ...state,
      requestsCache: {
        ...state.requestsCache,
        ...normalized
      }
    };
  };
}
function updateRequestCache(key, {
  ttl,
  value: v
} = {}) {
  const data = {
    value: v ?? 'full'
  };
  if (ttl) {
    data.timestamp = Date.now() + ttl;
  }
  return function (state) {
    return {
      ...state,
      requestsCache: {
        ...state.requestsCache,
        [key]: data
      }
    };
  };
}
function getRequestCache(key) {
  return function (state) {
    const cacheValue = state.requestsCache[key] ?? {
      value: 'none'
    };
    if (cacheValue.timestamp && cacheValue.timestamp < Date.now()) {
      return {
        value: 'none'
      };
    }
    return cacheValue;
  };
}
function selectIsRequestCached(key, options) {
  return pipe(distinctUntilKeyChanged('requestsCache'), (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => isRequestCached(key, options)(state)));
}
function isRequestCached(key, options) {
  return function (state) {
    const type = options?.value ?? 'full';
    return (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.coerceArray)(key).some(k => getRequestCache(k)(state).value === type);
  };
}
function skipWhileCached(store, key, options) {
  return function (source) {
    if (store.query(isRequestCached(key, {
      value: options?.value
    }))) {
      return options?.returnSource ?? EMPTY;
    }
    return source;
  };
}
function createRequestsCacheOperator(store) {
  return function (key, options) {
    return skipWhileCached(store, key, options);
  };
}
function clearRequestsCache() {
  return function (state) {
    return {
      ...state,
      requestsCache: {}
    };
  };
}
function withRequestsStatus(initialValue) {
  return {
    props: {
      requestsStatus: initialValue ?? {}
    },
    config: undefined
  };
}
function updateRequestsStatus(requestsOrKeys, value, error) {
  let normalized = requestsOrKeys;
  if (value) {
    normalized = requestsOrKeys.reduce((acc, key) => {
      acc[key] = resolveStatus(value, error);
      return acc;
    }, {});
  }
  return function (state) {
    return {
      ...state,
      requestsStatus: {
        ...state.requestsStatus,
        ...normalized
      }
    };
  };
}
function resolveStatus(value, error) {
  const newStatus = {
    value
  };
  if (value === 'error') {
    newStatus.error = error;
  }
  return newStatus;
}
function updateRequestStatus(key, value, error) {
  return function (state) {
    return {
      ...state,
      requestsStatus: {
        ...state.requestsStatus,
        [key]: resolveStatus(value, error)
      }
    };
  };
}
function getRequestStatus(key) {
  return function (state) {
    return state.requestsStatus[key] ?? {
      value: 'idle'
    };
  };
}
function selectRequestStatus(key, options) {
  return pipe(distinctUntilKeyChanged('requestsStatus'), (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => {
    const base = getRequestStatus(key)(state);
    if (options?.groupKey) {
      const parent = getRequestStatus(options.groupKey)(state);
      return parent.value === 'success' ? parent : base;
    }
    return base;
  }));
}
function selectIsRequestPending(key) {
  return pipe(distinctUntilKeyChanged('requestsStatus'), (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.select)(state => getRequestStatus(key)(state).value === 'pending'));
}
function trackRequestStatus(store, key, options) {
  return function (source) {
    return defer(() => {
      if (store.query(getRequestStatus(key)).value !== 'pending') {
        store.update(updateRequestStatus(key, 'pending'));
      }
      return source.pipe(tap({
        error(error) {
          store.update(updateRequestStatus(key, 'error', options?.mapError ? options?.mapError(error) : error));
        }
      }));
    });
  };
}
function createRequestsStatusOperator(store) {
  return function (key, options) {
    return trackRequestStatus(store, key, options);
  };
}
function initializeAsPending(keys) {
  return (0,_ngneat_elf__WEBPACK_IMPORTED_MODULE_0__.coerceArray)(keys).reduce((acc, key) => {
    acc[key] = {
      value: 'pending'
    };
    return acc;
  }, {});
}
function clearRequestsStatus() {
  return function (state) {
    return {
      ...state,
      requestsStatus: {}
    };
  };
}
function createRequestDataSource(params) {
  const {
    data$,
    store,
    dataKey,
    requestStatusOptions,
    requestKey,
    idleAsPending = false
  } = Reflect.has(params, 'requestKey') ? params : {
    ...params,
    requestKey: undefined
  };
  return {
    trackRequestStatus: options => trackRequestStatus(store, requestKey ?? options?.key, options),
    skipWhileCached: options => skipWhileCached(store, requestKey ?? options?.key, options),
    setSuccess(options) {
      return updateRequestStatus(requestKey ?? options?.key, 'success');
    },
    setCached(options) {
      return updateRequestCache(requestKey ?? options?.key, options);
    },
    data$: options => store.combine({
      data: data$(requestKey ?? options?.key),
      status: store.pipe(selectRequestStatus(requestKey ?? options?.key, requestStatusOptions || {}))
    }).pipe(map(({
      data,
      status
    }) => {
      return {
        [dataKey]: data,
        loading: idleAsPending ? status.value === 'pending' || status.value === 'idle' : status.value === 'pending',
        error: status.value === 'error' ? status.error : undefined
      };
    }), distinctUntilChanged((a, b) => {
      // if the status is the same, for example, `pending` and `pending`, and the `data` is the same
      // don't emit a redundant value
      return a[dataKey] === b[dataKey] && a.loading === b.loading && a.error === b.error;
    }))
  };
}
function initialResult() {
  return {
    isError: false,
    isLoading: true,
    isSuccess: false,
    status: 'loading',
    fetchStatus: 'idle',
    successfulRequestsCount: 0
  };
}
function getSource(key, initialValue, map) {
  const item = map.get(resolveKey(key));
  if (item) {
    return item.asObservable();
  }
  const newSource = new BehaviorSubject(initialValue);
  map.set(resolveKey(key), newSource);
  return newSource.asObservable();
}
function resolveKey(key) {
  return JSON.stringify(key);
}
const emitters = new Map();

// @public
function getRequestResult(key, {
  initialStatus
} = {}) {
  let result = initialResult();
  if (initialStatus === 'idle') {
    result = {
      ...result,
      status: 'idle',
      isLoading: false
    };
  }
  return getSource(key, result, emitters);
}
function updateRequestResult(key, newValue) {
  const result = emitters.get(resolveKey(key));
  if (result) {
    let hasChange = false;
    const currentResult = result.getValue();
    for (const key of Object.keys(newValue)) {
      if (currentResult[key] !== newValue[key]) {
        hasChange = true;
        break;
      }
    }
    hasChange && result.next({
      ...currentResult,
      ...newValue
    });
  }
}

// @public
function clearRequestsResult() {
  emitters.clear();
}

// @public
function deleteRequestResult(key) {
  emitters.delete(resolveKey(key));
}

// @public
function resetStaleTime(key) {
  updateRequestResult(key, {
    staleTime: undefined
  });
}

// @public
function joinRequestResult(...[key, options]) {
  return function (source) {
    return combineLatest([source, getRequestResult(key, options)]).pipe(map(([data, result]) => {
      return {
        ...result,
        data
      };
    }));
  };
}
function trackRequestResult(key, options) {
  return function (source) {
    return getRequestResult(key).pipe(take(1), switchMap(result => {
      const stale = options?.staleTime ? (result.staleTime ?? 0) < Date.now() : false;
      const preventConcurrentRequest = options?.preventConcurrentRequest !== undefined ? options.preventConcurrentRequest : true;
      const cacheResponseData = options?.cacheResponseData;
      if (result.isSuccess && !options?.skipCache && !stale) {
        return of(result.responseData);
      }
      if (result.fetchStatus === 'fetching' && preventConcurrentRequest && !options?.skipCache) {
        return getRequestResult(key).pipe(filter(requestResult => requestResult.fetchStatus === 'idle'), switchMap(requestResult => {
          if (requestResult.isError) {
            return throwError(() => requestResult.error);
          }
          if (requestResult.isSuccess) {
            return of(requestResult.responseData);
          }
          return EMPTY;
        }), take(1));
      }
      updateRequestResult(key, {
        isLoading: true,
        isError: false,
        isSuccess: false,
        status: 'loading',
        fetchStatus: 'fetching'
      });
      let sourceData;
      return source.pipe(tap({
        error(error) {
          updateRequestResult(key, {
            isError: true,
            isLoading: false,
            isSuccess: false,
            status: 'error',
            fetchStatus: 'idle',
            errorUpdatedAt: Date.now(),
            error
          });
        },
        next(data) {
          sourceData = data;
        },
        complete() {
          const newResult = {
            isLoading: false,
            isSuccess: true,
            isError: false,
            status: 'success',
            fetchStatus: 'idle',
            responseData: cacheResponseData ? sourceData : undefined,
            dataUpdatedAt: Date.now(),
            successfulRequestsCount: result.successfulRequestsCount + 1
          };
          if (options?.staleTime) {
            newResult.staleTime = Date.now() + options.staleTime;
          }
          updateRequestResult(key, newResult);
          if (options?.additionalKeys) {
            const mainKey = resolveKey(key);
            for (const keys of options.additionalKeys(sourceData)) {
              emitters.set(resolveKey(keys), emitters.get(mainKey));
            }
          }
        }
      }));
    }));
  };
}
function filterSuccess() {
  return filter(result => result.status === 'success');
}
function filterError() {
  return filter(result => result.status === 'error');
}
function mapResultData(mapFn) {
  return pipe(map(result => {
    return {
      ...result,
      data: result.data != null ? mapFn(result.data) : result.data
    };
  }));
}


/***/ })

}]);
//# sourceMappingURL=default-src_app_apps_shared_services_api_service_ts-node_modules_ngneat_elf-entities_index_es-6c9458.js.map